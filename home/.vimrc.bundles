set runtimepath+=~/.vim/bundle/neobundle.vim/

call neobundle#begin(expand('~/.vim/bundle'))

" Let NeoBundle manage NeoBundle
NeoBundleFetch 'Shougo/neobundle.vim'

" libs " {{{
NeoBundle 'Shougo/vimproc.vim', {
            \ 'build' : {
            \         'windows' : 'tools\\update-dll-mingw',
            \         'cygwin' : 'make -f make_cygwin.mak',
            \         'mac' : 'make -f make_mac.mak',
            \         'linux' : 'make',
            \         'unix' : 'gmake',
            \        },
            \ }
NeoBundle 'vim-jp/vital.vim'
" }}}

" Unite " {{{
NeoBundle 'Shougo/unite.vim', { 'depends' : [ 'Shougo/vimproc.vim' ] }
NeoBundle 'Shougo/neomru.vim', { 'depends' : [ 'Shougo/unite.vim' ] }
NeoBundle 'Shougo/tabpagebuffer.vim', { 'depends' : [ 'Shougo/unite.vim' ] }
NeoBundle 'Shougo/unite-outline', { 'depends:' : [ 'Shougo/unite.vim' ] }
NeoBundle 'Shougo/unite-help', { 'depends' : [ 'Shougo/unite.vim' ] }
NeoBundle 'tsukkee/unite-tag', { 'depends' : [ 'Shougo/unite.vim' ] }
NeoBundle 'osyo-manga/unite-quickfix', { 'depends' : [ 'Shougo/unite.vim' ] }
NeoBundle 'Murlocks/unite-everything', { 'depends:' : [ 'Shougo/unite.vim' ] }
NeoBundle 'Shougo/vimfiler.vim', { 'depends:' : [ 'Shougo/unite.vim' ] }
NeoBundle 'thinca/vim-editvar'
" }}}

" Completion " {{{
NeoBundle 'Shougo/neocomplete'
NeoBundle 'Shougo/neoinclude.vim', { 'depends:' : [ 'Shougo/neocomplete' ] }
NeoBundle 'Shougo/context_filetype.vim', { 'depends:' : [ 'Shougo/neocomplete' ] }
NeoBundle 'Shougo/neco-syntax', { 'depends:' : [ 'Shougo/neocomplete' ] }
NeoBundle 'Shougo/neco-vim', { 'depends:' : [ 'Shougo/neocomplete' ] }
NeoBundle 'osyo-manga/vim-marching'
" NeoBundle 'Shougo/neosnippet'
" NeoBundle 'Shougo/neosnippet-snippets'
NeoBundle 'davidhalter/jedi'
NeoBundle 'SirVer/ultisnips'
NeoBundle 'honza/vim-snippets'
" NeoBundle 'Valloric/YouCompleteMe'
" NeoBundle 'rdnetto/YCM-Generator'
" }}}

" Looks " {{{
NeoBundle 'atweiden/vim-colors-behelit'
NeoBundle 'crusoexia/vim-monokai'
NeoBundle 'tomasr/molokai'
NeoBundle 'chriskempson/base16-vim'
NeoBundle 'baskerville/bubblegum'
NeoBundle 'junegunn/seoul256.vim'
NeoBundle 'jonathanfilip/lucius'
NeoBundle 'altercation/vim-colors-solarized'
NeoBundle 'chriskempson/base16-vim'
"NeoBundle 'powerline/powerline', {'rtp': 'powerline/bindings/vim/'}
NeoBundle 'bling/vim-airline'
NeoBundle 'bling/vim-bufferline'
NeoBundle 'nathanaelkane/vim-indent-guides'
NeoBundle 'hynek/vim-python-pep8-indent'
" NeoBundle 'myusuf3/numbers.vim'
NeoBundle 'osyo-manga/vim-over'
" NeoBundle 'amix/vim-zenroom'
NeoBundle 'junegunn/goyo.vim'
NeoBundle 'amix/vim-zenroom2', { 'depends:' : [ 'junegunn/goyo.vim' ] }
" NeoBundle 'mhinz/vim-signify'
NeoBundle 'airblade/vim-gitgutter'
" }}}

" General " {{{
" NeoBundle 'szw/vim-ctrlspace'
NeoBundle 'Shougo/vimshell.vim', { 'depends:' : [ 'Shougo/vimproc.vim' ] }
NeoBundle 'airblade/vim-rooter'
NeoBundle 'tommcdo/vim-exchange'
NeoBundle 'sheerun/vim-polyglot'
NeoBundle 'mbbill/undotree'
NeoBundle 'scrooloose/syntastic'
NeoBundle 'jiangmiao/auto-pairs' " Doesn't play well with unite's preview window - fixed??
" NeoBundle 'kana/vim-smartinput'
" NeoBundle 'cohama/vim-smartinput-endwise', { 'depends' : [ 'kana/vim-smartinput' ] }
" NeoBundle 'cohama/lexima.vim'
NeoBundle 'matchit.zip'
NeoBundle 'haya14busa/incsearch.vim'
NeoBundle 'haya14busa/incsearch-easymotion.vim', { 'depends:' : [ 'haya14busa/incsearch.vim' ] }
NeoBundle 'osyo-manga/vim-over'
" NeoBundle 'wellle/targets.vim'
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'tpope/vim-unimpaired'
" NeoBundle 'kana/vim-repeat'
NeoBundle 'tpope/vim-repeat'
NeoBundle 'tpope/vim-surround'
NeoBundle 'godlygeek/tabular'
NeoBundle 'plasticboy/vim-markdown', { 'depends:' : [ 'godlygeek/tabular' ] }
NeoBundle 'vim-pandoc/vim-pandoc'
NeoBundle 'haya14busa/vim-asterisk'
" NeoBundle 'tpope/vim-commentary'
NeoBundle 'tyru/caw.vim'
" NeoBundle 'tomtom/tcomment_vim'
NeoBundle 'kristijanhusak/vim-multiple-cursors'
NeoBundle 'Lokaltog/vim-easymotion'
NeoBundle 'kana/vim-submode'
NeoBundle 'Murlocks/vimux'
NeoBundle 'rhysd/committia.vim'
NeoBundle 'justinmk/vim-sneak'
" NeoBundle 'mattn/emmet-vim'
NeoBundle 'thinca/vim-quickrun'
NeoBundle 'LeafCage/foldCC.vim'
NeoBundle 'rhysd/accelerated-jk'
NeoBundle 'FooSoft/vim-argwrap'
NeoBundle 'takac/vim-hardtime'
NeoBundle 'xolox/vim-easytags', { 'depends' : [ 'xolox/vim-misc' ] }
NeoBundle 'xolox/vim-misc'
" }}}

" Text object " {{{
NeoBundle 'kana/vim-textobj-user'
NeoBundle 'kana/vim-textobj-entire', { 'depends' : 'kana/vim-textobj-user' }
NeoBundle 'kana/vim-textobj-function', { 'depends' : 'kana/vim-textobj-user' }
NeoBundle 'kana/vim-textobj-indent', { 'depends' : 'kana/vim-textobj-user' }
NeoBundle 'rhysd/vim-textobj-ruby', { 'depends' : 'kana/vim-textobj-user' }
NeoBundle 'osyo-manga/vim-textobj-multiblock', { 'depends' : 'kana/vim-textobj-user' }
NeoBundle 'osyo-manga/vim-textobj-multitextobj', { 'depends' : 'kana/vim-textobj-user' }
NeoBundle 'osyo-manga/vim-textobj-blockwise', { 'depends' : 'kana/vim-textobj-user' }
NeoBundle 'Julian/vim-textobj-variable-segment', { 'depends' : 'kana/vim-textobj-user' }
NeoBundle 'sgur/vim-textobj-parameter', { 'depends' : 'kana/vim-textobj-user' }
NeoBundle 'thinca/vim-textobj-between', { 'depends' : 'kana/vim-textobj-user' }
" }}}

" Operator " {{{
NeoBundle 'kana/vim-operator-user'
NeoBundle 'kana/vim-operator-replace', { 'depends' : 'kana/vim-operator-user' }
" NeoBundle 'rhysd/vim-operator-surround', { 'depends' : 'kana/vim-operator-user' }
NeoBundle 'tyru/operator-html-escape.vim', { 'depends' : 'kana/vim-operator-user' }
NeoBundle 'osyo-manga/vim-operator-blockwise', { 'depends' : 'kana/vim-operator-user' }
" }}}

" Local Plugins (Arch) " {{{
NeoBundleLocal /usr/share/vim/vimfiles/plugin
NeoBundle 'fzf.vim'
" }}}

" Plugin Config " {{{
let g:neobundle#install_process_timeout = 1500

set rtp+=~/.fzf

if neobundle#tap('vim-airline') " {{{

    " let g:airline_theme='behelit'
    let g:airline_theme='bubblegum'
    " let g:airline_theme='sol'
    let g:airline_powerline_fonts = 1
    let g:airline#extensions#bufferline#enabled = 0
    " let g:airline#extensions#tabline#enabled = 1
    let g:airline#extensions#whitespace#enabled = 0

    let g:airline_mode_map = {
                            \ '__' : '-',
                            \ 'n'    : 'N',
                            \ 'i'    : 'I',
                            \ 'R'    : 'R',
                            \ 'v'    : 'V',
                            \ 'V'    : 'V-L',
                            \ 'c'    : 'C',
                            \ 's'    : 'S',
                            \ 'S'    : 'S-L',
                            \ }

endif " }}}

if neobundle#tap('vim-bufferline') " {{{

  " let g:bufferline_echo = 0
  " autocmd VimEnter *
  "   \ let &statusline='%{bufferline#refresh_status()}'
  "     \ .bufferline#get_status_string()
  " let g:bufferline_rotate = 2

endif " }}}

if neobundle#tap('vital.vim') " {{{

    function! neobundle#tapped.hooks.on_source(bundle)
        let g:V = vital#of('vital')
        let g:S = g:V.import("Web.HTTP")
        let g:L = g:V.import("Data.List")

        function! DecodeURI(uri)
            return g:S.decodeURI(a:uri)
        endfunction

        function! EncodeURI(uri)
            return g:S.encodeURI(a:uri)
        endfunction

        command -nargs=1 DecodeURI echo DecodeURI(<args>)
        command -nargs=1 EncodeURI echo EncodeURI(<args>)

    endfunction

endif " }}}

if neobundle#tap('neocomplete') " {{{

    let g:neocomplete#enable_at_startup = 1

    let g:neocomplete#enable_auto_delimiter = 1
    let g:neocomplete#max_list = 15
    let g:neocomplete#force_overwrite_completefunc = 1
    let g:neocomplete#disable_auto_complete = 0
    " let g:neocomplete#enable_auto_close_preview = 1

    " Use smartcase.
    let g:neocomplete#enable_smart_case = 1
    let g:neocomplete#enable_camel_case = 1

    " Use fuzzy completion.
    let g:neocomplete#enable_fuzzy_completion = 1

    " autocmd CompleteDone * pclose

    " Set auto completion length.
    let g:neocomplete#auto_completion_start_length = 3
    " Set manual completion length.
    let g:neocomplete#manual_completion_start_length = 3
    " Set minimum keyword length.
    let g:neocomplete#min_keyword_length = 3

    " let g:neocomplete#enable_auto_select = 1

    " Define keyword.
    if !exists('g:neocomplete#keyword_patterns')
        let g:neocomplete#keyword_patterns = {}
    endif
    if !exists('g:neocomplete#sources#omni#input_patterns')
        let g:neocomplete#sources#omni#input_patterns = {}
    endif
    if !exists('g:neocomplete#sources#omni#functions')
        let g:neocomplete#sources#omni#functions = {}
    endif
    if !exists('g:neocomplete#force_omni_input_patterns')
        let g:neocomplete#force_omni_input_patterns = {}
    endif

    let g:neocomplete#keyword_patterns['default'] = '\h\w*'


    " Python Completions for neocomplete
    autocmd FileType python setlocal omnifunc=jedi#completions
    let g:jedi#completions_enabled = 0
    let g:jedi#auto_vim_configuration = 0
    let g:neocomplete#force_omni_input_patterns.python =
                \ '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'

    " Use eclim for java
    if !exists('g:neocomplete#force_omni_input_patterns')
        let g:neocomplete#force_omni_input_patterns = {}
    endif
    let g:neocomplete#force_omni_input_patterns.java =
                \ '\%(\h\w*\|)\)\.\w*'

    " Use vim-marching for C++
    let g:neocomplete#force_omni_input_patterns.cpp =
                \ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'

    " Change file ranking
    " call neocomplete#custom#source('file', 'rank', 10)

    " imap <silent><expr><C-l> neosnippet#expandable() ?
    "                         \ "\<Plug>(neosnippet_expand_or_jump)" : (pumvisible() ?
    "                         \ "\<C-e>" : "\<Plug>(neosnippet_expand_or_jump)")

    " imap <expr><silent><C-l>         neocomplete#mappings#close_popup() .
    "             \ "\<Plug>(neosnippet_jump_or_expand)"
    " smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
    "             \ neocomplete#mappings#close_popup() . "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
    " " smap <TAB> <Right><Plug>(neosnippet_jump_or_expand)
    " smap <C-l> <Right><Plug>(neosnippet_jump_or_expand)
    " xmap <C-l> <Right><Plug>(neosnippet_jump_or_expand)
    "
    " inoremap <expr><C-g> neocomplete#undo_completion()
    " inoremap <expr><C-e> neocomplete#complete_common_string()
    "
    " " <CR>: close popup
    " " <s-CR>: close popup and save indent.
    " inoremap <expr><s-CR> pumvisible() ? neocomplete#smart_close_popup()."\<CR>" : "\<CR>"
    "
    " function! CleverCr()
    "     if pumvisible()
    "         if neosnippet#expandable()
    "             let exp = "\<Plug>(neosnippet_expand_or_jump)"
    "             return exp
    "         else
    "             return neocomplete#smart_close_popup()
    "         endif
    "     else
    "         return "\<CR>"
    "     endif
    " endfunction
    "
    " " <CR> close popup and save indent or expand snippet
    " inoremap <expr> <CR> CleverCr()
    " " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><C-h> neocomplete#smart_close_popup()

    "
    function! s:check_back_space() "{{{
        let col = col('.') - 1
        return !col || getline('.')[col - 1]    =~ '\s'
    endfunction"}}}
    "
    " imap <expr> <Tab> CleverTab()
    " function! CleverTab()
    "     if <SID>check_back_space()
    "         " nothing to match on empty string
    "         return "\<Tab>"
    "     else
    "         " existing text matching
    "         if neosnippet#jumpable()
    "             return neocomplete#mappings#close_popup() . "\<Plug>(neosnippet_expand_or_jump)"
    "         elseif pumvisible()
    "             return "\<C-n>"
    "         else
    "             return neocomplete#start_manual_complete()
    "         endif
    "     endif
    " endfunction

    " Next menu item, expand snippet, jump to next placeholder or insert literal tab
    let g:UltiSnipsJumpForwardTrigger="<NOP>"
    let g:ulti_expand_or_jump_res = 0
    function! ExpandSnippetOrJumpForwardOrReturnTab()
        let snippet = UltiSnips#ExpandSnippetOrJump()
        if <SID>check_back_space()
            return "\<TAB>"
        else
            if g:ulti_expand_or_jump_res > 1
                return snippet
            else
                return neocomplete#start_manual_complete()
            endif
        endif
    endfunction
    inoremap <expr> <TAB>
        \ pumvisible() ? "\<C-n>" :
        \ "<C-R>=ExpandSnippetOrJumpForwardOrReturnTab()<CR>"
    " jump to next placeholder otherwise do nothing
    snoremap <buffer> <silent> <TAB>
        \ <ESC>:call UltiSnips#JumpForwards()<CR>
    " snoremap <buffer> <silent> <C-l>
    "     \ <ESC>:call UltiSnips#JumpForwards()<CR>
    inoremap <expr><silent><C-l>
        \ pumvisible() ? neocomplete#complete_common_string() : "\<C-y>"

    " previous menu item, jump to previous placeholder or do nothing
    let g:UltiSnipsJumpBackwordTrigger = "<NOP>"
    inoremap <expr> <S-TAB>
        \ pumvisible() ? "\<C-p>" :
        \ "<C-R>=UltiSnips#JumpBackwards()<CR>"

    " jump to previous placeholder otherwise do nothing
    snoremap <buffer> <silent> <S-TAB>
        \ <ESC>:call UltiSnips#JumpBackwards()<CR>

    " expand snippet, close menu or insert newline
    " let g:UltiSnipsExpandTrigger = "<NOP>"
    " let g:ulti_expand_or_jump_res = 0
    " inoremap <silent> <C-l> <C-r>=<SID>ExpandSnippetOrReturnEmptyString()<CR>
    " vnoremap <silent> <C-l> <C-r>=<SID>ExpandSnippetOrReturnEmptyString()<CR>
    " function! s:ExpandSnippetOrReturnEmptyString()
    "     if pumvisible()
    "         let snippet = UltiSnips#ExpandSnippetOrJump()
    "         if g:ulti_expand_or_jump_res > 0
    "             return snippet
    "         else
    "             return "\<C-y>\<CR>"
    "         endif
    "     else
    "         let snippet = UltiSnips#JumpForwards()
    "         return "\<ESC>" . snippet
    "     endif
    " endfunction

    let g:UltiSnipsExpandTrigger = "<NOP>"
    let g:ulti_expand_or_jump_res = 0
    inoremap <silent> <CR> <C-r>=<SID>ExpandSnippetOrReturnEmptyString()<CR>
    function! s:ExpandSnippetOrReturnEmptyString()
        if pumvisible()
            let snippet = UltiSnips#ExpandSnippetOrJump()
            if g:ulti_expand_or_jump_res > 0
                return snippet
            else
                return "\<C-y>\<CR>"
            endif
        else
            " return AutoPairsReturn() . "\<CR>"
            return "\<CR>"
        endif
    endfunction

    inoremap <expr><C-h> neocomplete#smart_close_popup()

    inoremap <expr><BS>  neocomplete#smart_close_popup()."\<C-h>"

    " Command line buffer.
    nnoremap <SID>(command-line-enter) q:
    xnoremap <SID>(command-line-enter) q:
    nnoremap <SID>(command-line-norange) q:<C-u>

    nmap ;;  <SID>(command-line-enter)
    xmap ;;  <SID>(command-line-enter)

    autocmd CmdwinEnter * call s:init_cmdwin()

    function! s:init_cmdwin()
      let b:neocomplete_sources = ['vim']

      nnoremap <buffer><silent> q :<C-u>quit<CR>
      nnoremap <buffer><silent> <TAB> :<C-u>quit<CR>
      inoremap <buffer><expr><CR> neocomplete#close_popup()."\<CR>"
      inoremap <buffer><expr><C-h> col('.') == 1 ?
            \ "\<ESC>:quit\<CR>" : neocomplete#cancel_popup()."\<C-h>"
      inoremap <buffer><expr><BS> col('.') == 1 ?
            \ "\<ESC>:quit\<CR>" : neocomplete#cancel_popup()."\<C-h>"

      " Completion.
      inoremap <buffer><expr><TAB>  pumvisible() ?
            \ "\<C-n>" : <SID>check_back_space() ? "\<TAB>" : neocomplete#start_manual_complete()

      startinsert!
    endfunction

    call neobundle#untap()

endif " }}}

if neobundle#tap('neosnippet') " {{{

    call neobundle#config({
                \     'autoload' : {
                \         'unite_sources' : [ 'neosnippet', 'neosnippet/user', 'neosnippet/runtime' ]
                \     }
                \ })

    autocmd InsertLeave * NeoSnippetClearMarkers

    " smap <silent>L         <Plug>(neosnippet_jump_or_expand)
    " xmap <silent>L         <Plug>(neosnippet_start_unite_snippet_target)
    " imap <silent>K         <Plug>(neosnippet_expand_or_jump)
    " smap <silent>K         <Plug>(neosnippet_expand_or_jump)
    " imap <silent>G         <Plug>(neosnippet_expand)
    " imap <silent>S         <Plug>(neosnippet_start_unite_snippet)
    " xmap <silent>o         <Plug>(neosnippet_register_oneshot_snippet)
    " xmap <silent>U         <Plug>(neosnippet_expand_target)
    "
    " imap <expr><silent>L         neocomplete#mappings#close_popup() .
    "             \ "\<Plug>(neosnippet_jump_or_expand)"

    " let g:neosnippet#enable_snipmate_compatibility = 1

    " let g:snippets_dir = '~/.vim/snippets/,~/.vim/bundle/snipmate/snippets/'
    let g:neosnippet#snippets_directory = '~/.vim/snippets'

endif " }}}

if neobundle#tap('YouCompleteMe') " {{{

    let g:ycm_confirm_extra_conf        = 0
    let g:ycm_global_ycm_extra_conf = '~/.vim/ycm.py'
    let g:ycm_extra_conf_vim_data     = ['&filetype']
    let g:ycm_autoclose_preview_window_after_insertion = 1

endif " }}}

if neobundle#tap('ultisnips') " {{{

    " let g:UltiSnipsExpandTrigger="<C-l>"
    let g:UltiSnipsJumpForwardTrigger = "<c-j>"
    let g:UltiSnipsJumpBackwardTrigger = "<c-k>"

endif " }}}

if neobundle#tap('unite.vim') " {{{

    call neobundle#config({
                \     'autoload' : {
                \         'commands' : [
                \             {
                \                 'name' : 'Unite',
                \                 'complete' : 'customlist,unite#complete_source'
                \             },
                \             'UniteWithCursorWord',
                \             'UniteWithInput'
                \         ]
                \     }
                \ })

    " Use The Silver/Platinum Searcher
    if executable('pt')
        let g:unite_source_rec_async_command = 'pt --follow --nocolor --nogroup --hidden ' .
                    \ '--ignore ''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'' ' .
                    \ '--ignore ''**/*.pyc'' -g ""'
        let g:unite_source_grep_command = 'pt'
        let g:unite_source_grep_default_opts = '--nogroup --nocolor'
        let g:unite_source_grep_recursive_opt = ''
        let g:unite_source_grep_encoding = 'utf-8'
    elseif executable('ag')
        let g:unite_source_rec_async_command = 'ag --follow --nocolor --nogroup --hidden ' .
                    \ '--ignore ''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'' ' .
                    \ '--ignore ''**/*.pyc'' -g ""'
        let g:unite_source_grep_command = 'ag'
        let g:unite_source_grep_default_opts = '--nogroup --nocolor --column'
        let g:unite_source_grep_recursive_opt = ''
    endif

    function! s:unite_menu_map_func(key, value)
        let [word, value] = a:value
        if isdirectory(value)
            return {
                        \     'word' : '[directory] ' . word,
                        \     'kind' : 'directory',
                        \     'action__directory' : value
                        \ }
        elseif !empty(glob(value))
            return {
                        \     'word' : '[file] ' . word,
                        \     'kind' : 'file',
                        \     'default_action' : 'tabdrop',
                        \     'action__path' : value,
                        \ }
        else
            return {
                        \     'word' : '[command] ' . word,
                        \     'kind' : 'command',
                        \     'action__command' : value
                        \ }
        endif
    endfunction

    function! neobundle#tapped.hooks.on_source(bundle)

        " General
        let g:unite_source_history_yank_enable = 1
        let g:unite_force_overwrite_statusline = 0
        let g:unite_kind_jump_list_after_jump_scroll=0
        let g:unite_enable_start_insert = 0
        let g:unite_source_rec_min_cache_files = 1000
        let g:unite_source_rec_max_cache_files = 5000
        let g:unite_source_file_mru_long_limit = 100000
        let g:unite_source_file_mru_limit = 100000
        let g:unite_source_directory_mru_long_limit = 100000
        let g:unite_prompt = '‚ùØ '

        " Use buffer name instead of file path for buffer / buffer_tab source
        let s:filter = { 'name' : 'converter_buffer_word' }

        function! s:filter.filter(candidates, context)
            for candidate in a:candidates
                " if !filereadable(candidate.word)
                "     let candidate.word = bufname(candidate.action__buffer_nr)
                " endif
                let candidate.word = bufname(candidate.action__buffer_nr)
                if candidate.word == ''
                    let candidate.word = 'No Name'
                end
            endfor
            return a:candidates
        endfunction

        call unite#define_filter(s:filter)
        unlet s:filter
        call unite#custom_source('buffer', 'converters', 'converter_buffer_word')
        call unite#custom_source('buffer_tab', 'converters', 'converter_buffer_word')

        " Unite-menu
        let g:unite_source_menu_menus = get(g:, 'unite_source_menu_menus', {})
        let g:unite_source_menu_menus.global = { 'description' : 'global shortcut' }
        let g:unite_source_menu_menus.unite = { 'description' : 'unite shortcut' }
        let g:unite_source_menu_menus.global.map = function('s:unite_menu_map_func')
        let g:unite_source_menu_menus.unite.map = function('s:unite_menu_map_func')
        let g:unite_source_menu_menus.global.candidates = [
                    \     [ 'vimrc' , $MYVIMRC ],
                    \     [ 'vimrc.bundles' , '~/.vimrc.bundles' ],
                    \     [ 'vimfiler' ,    ':VimFiler' ],
                    \     [ 'other', ":call Unite_filetype_menu('-start-insert')" ],
                    \ ]
        let g:unite_source_menu_menus.unite.candidates = []
        let g:unite_source_menu_filetype_candidates = {}
        let g:unite_source_menu_filetype_candidates._ = [
                    \     [ 'neobundle/update' , ':Unite neobundle/update -log' ],
                    \     [ 'neobundle/install' , ':Unite neobundle/install -log' ],
                    \     [ 'files', ':Unite -start-insert -buffer-name=files buffer_tab file file_mru'],
                    \     [ 'function', ':Unite -start-insert -default-action=edit function'],
                    \     [ 'variable', ':Unite -start-insert -default-action=edit variable'],
                    \     [ 'outline', ':Unite -start-insert outline'],
                    \     [ 'help', ':Unite -start-insert help'],
                    \     [ 'buffer', ':Unite -start-insert buffer'],
                    \     [ 'line', ':Unite -start-insert -auto-preview -buffer-name=search line'],
                    \     [ 'grep', ':Unite grep -max-multi-lines=1 -truncate -default-action=tabopen -buffer-name=unite_grep'],
                    \     [ 'source', ':Unite -start-insert source'],
                    \     [ 'locate', ':Unite -start-insert locate'],
                    \     [ 'theme', ':Unite -auto-preview colorscheme'],
                    \     [ 'resume grep', ':UniteResume unite_grep'],
                    \ ]


        " call unite#filters#sorter_default#use(['sorter_selecta'])
        " call unite#filters#matcher_default#use(['matcher_fuzzy']) "use fuzz matching

        " Don't use selecta sorter or fuzzy matching for outline
        " call unite#custom#source('outline', 'matcher', 'matcher_context')
        " call unite#custom#source('outline', 'sorter', 'sorter_nothing')

        " call unite#custom#source(
        "             \ 'buffer_tab,file_rec/async,file_rec,file_mru,outline', 'matchers',
        "             \ ['matcher_fuzzy'])
        " call unite#custom#source(
        "             \ 'file_rec/async,file_rec,file_mru', 'converters',
        "             \ ['converter_file_directory'])

        let g:unite_source_rec_max_cache_files = 0
        " call unite#custom#source('file_rec,file_rec/async',
        "             \ 'max_candidates', 100)

        " call unite#custom#profile('files', 'filters', 'sorter_selecta')
        call unite#custom#source(
                    \ 'outline,menu', 'matchers',
                    \ ['matcher_fuzzy'])
        call unite#custom#source(
                    \ 'file_mru,buffer_tab,file_rec,file_rec/async,file_rec/git', 'matchers',
                    \ ['converter_relative_word', 'matcher_fuzzy'])
        call unite#custom#source(
                    \ 'buffer_tab,file_rec/async,file_rec,file_mru,outline', 'sorter',
                    \ ['sorter_selecta'])
        call unite#custom#source(
                    \ 'file_rec,file_rec/async,file_rec/git,file_mru', 'converters',
                    \ ['converter_file_directory'])
        call unite#custom#profile('files', 'filters', ['sorter_rank'])
        call unite#custom#source(
                    \ 'file_rec,file_rec/async', 'required_pattern_length',
                    \ 1)

        " Like ctrlp.vim settings.
        call unite#custom#profile('default', 'context', {
                    \     'start_insert': 1,
                    \     'winheight': 10,
                    \     'direction': 'botright',
                    \ })

    endfunction

    nnoremap <silent> <CR>    :<C-u>Unite -start-insert menu:global<CR>
    " nnoremap <silent> <C-o> :<C-u>Unite -start-insert -buffer-name=files buffer_tab file file_mru<CR>
    nnoremap <silent> <Space>f   :<C-u>Unite -start-insert -buffer-name=outline outline<CR>
    " nnoremap <silent> <C-b> :<C-u>Unite -start-insert -quick-match buffer<CR>
    nnoremap <silent> <Space>s       :<C-u>Unite -start-insert -auto-preview -buffer-name=search line<CR>
    nnoremap <silent> <Space><C-s>   :<C-u>UniteWithCursorWord -auto-preview -start-insert -buffer-name=search line<CR>
    " nnoremap <silent> <C-l> :<C-u>Unite -start-insert -buffer-name=files buffer_tab file_rec/git<CR>
    nnoremap <silent> <Space>g   :<C-u>Unite grep -max-multi-lines=1 -truncate -default-action=tabopen -buffer-name=unite_grep<CR>
    nnoremap <silent> <Space>p   :<C-u>Unite -start-insert -buffer-name=files buffer_tab file_rec/async:! file_mru<CR>
    " nnoremap <silent> <C-e> :<C-u>Unite -start-insert -buffer-name=everything everything<CR>
    nnoremap <silent> <Space>y   :<C-u>Unite -buffer-name=yank history/yank<CR>

    nnoremap <silent> <Space>m :<C-u>call Unite_filetype_menu('-start-insert')<CR>
    function! Unite_filetype_menu(options)
        let filetypes = split(&ft, '\.')
        let candidate_sets = map(
                    \     add(filter(filetypes, 'has_key(g:unite_source_menu_filetype_candidates, v:val)'), '_'),
                    \     'g:unite_source_menu_filetype_candidates[v:val]'
                    \ )
        let candidates = g:L.flatten(candidate_sets, 1)
        let g:unite_source_menu_menus.unite.candidates = candidates
        execute ':Unite menu:unite ' . a:options
    endfunction

    " nnoremap <silent> <C-p>    :<C-u>call Unite_project_files('-start-insert')<CR>
    " function! Unite_project_files(options)
    "     if exists('b:projectlocal_root_dir')
    "         execute ':Unite file_rec:' . b:projectlocal_root_dir . ' ' . a:options
    "     else
    "         echo "You are not in any project."
    "     endif
    " endfunction

    if neobundle#is_installed('unite-quickfix')
        nnoremap <silent> <Space>q    :<C-u>Unite -no-quit -auto-preview -no-split quickfix<CR>
    endif
    if neobundle#is_installed('unite-help')
        nnoremap <silent> <Space>o    :<C-u>Unite -start-insert -auto-preview
                    \ -no-split outline<CR>
    endif
    if neobundle#is_installed('unite-outline')
        nnoremap <silent> <Space>h    :<C-u>Unite -start-insert help<CR>
    endif

    au FileType unite imap <buffer> <CR>            <Plug>(unite_do_default_action)
    au FileType unite nmap <buffer> <ESC>            <Plug>(unite_exit)
    au FileType unite nmap <buffer> <c-c>            <Plug>(unite_exit)

    call neobundle#untap()

endif " }}}

if neobundle#tap('vim-textobj-multiblock') " {{{

    let g:textobj_multiblock_blocks = [
                \     ['(', ')', 1],
                \     ['[', ']', 1],
                \     ['{', '}', 1],
                \     ['<', '>', 1],
                \     ['"', '"', 1],
                \     ["'", "'", 1],
                \     ['`', '`', 1],
                \     ['|', '|', 1],
                \ ]
    let g:textobj_multiblock_search_limit = 20

endif " }}}

if neobundle#tap('vim-textobj-blockwise') " {{{

    vmap <expr> iw mode() == "\<C-v>" ? textobj#blockwise#mapexpr('iw') : 'iw'

endif " }}}

if neobundle#tap('vim-operator-blockwise') " {{{

    nmap YY <Plug>(operator-blockwise-yank)
    nmap DD <Plug>(operator-blockwise-delete)
    nmap CC <Plug>(operator-blockwise-change)
    nmap <expr> SS operator#blockwise#mapexpr("\<Plug>(operator-replace)")

endif " }}}

if neobundle#tap('vim-textobj-multiblock') " {{{

    omap ab <Plug>(textobj-multiblock-a)
    omap ib <Plug>(textobj-multiblock-i)
    vmap ab <Plug>(textobj-multiblock-a)
    vmap ib <Plug>(textobj-multiblock-i)

endif " }}}

if neobundle#tap('vim-submode') " {{{

    function! neobundle#tapped.hooks.on_source(bundle)
        let g:submode_keep_leaving_key = 1
        " tab moving
        call submode#enter_with('changetab', 'n', '', 'gt', 'gt')
        call submode#enter_with('changetab', 'n', '', 'gT', 'gT')
        call submode#map('changetab', 'n', '', 't', 'gt')
        call submode#map('changetab', 'n', '', 'T', 'gT')
        " undo/redo
        " call submode#enter_with('undo/redo', 'n', '', '<C-r>', '<C-r>')
        " call submode#enter_with('undo/redo', 'n', '', 'u', 'u')
        " call submode#map('undo/redo', 'n', '', '<C-r>', '<C-r>')
        " call submode#map('undo/redo', 'n', '', 'u', 'u')
        " move between fold
        call submode#enter_with('movefold', 'n', '', 'zj', 'zjzMzvzz')
        call submode#enter_with('movefold', 'n', '', 'zk', 'zkzMzv[zzz')
        call submode#map('movefold', 'n', '', 'j', 'zjzMzvzz')
        call submode#map('movefold', 'n', '', 'k', 'zkzMzv[zzz')
        " resize window
        call submode#enter_with('winsize', 'n', '', '<C-w>>', '<C-w>>')
        call submode#enter_with('winsize', 'n', '', '<C-w><', '<C-w><')
        call submode#enter_with('winsize', 'n', '', '<C-w>+', '<C-w>+')
        call submode#enter_with('winsize', 'n', '', '<C-w>-', '<C-w>-')
        call submode#map('winsize', 'n', '', '>', '<C-w>>')
        call submode#map('winsize', 'n', '', '<', '<C-w><')
        call submode#map('winsize', 'n', '', '+', '<C-w>+')
        call submode#map('winsize', 'n', '', '-', '<C-w>-')
        " TODO: Repeat last executed macro. umaku dekinai...
        " call submode#enter_with('macro/a', 'n', '', '@a', '@a')
        " call submode#map('macro/a', 'n', '', 'a', '@a')
    endfunction

    call neobundle#untap()

endif " }}}

if neobundle#tap('vimux') " {{{

    nmap <Leader>rb :call VimuxRunCommand("clear; rspec " . bufname("%"))<CR>
    nmap <Leader>vp :VimuxPromptCommand<CR>
    nmap <Leader>vl :VimuxRunLastCommand<CR>
    nmap <Leader>vi :VimuxInspectRunner<CR>
    nmap <Leader>vq :VimuxCloseRunner<CR>
    nmap <Leader>vx :VimuxInterruptRunner<CR>
    nmap <Leader>vz :call VimuxZoomRunner()<CR>
    nmap <Leader>vc :call VimuxRunCommand('clear')<CR>

endif " }}}

if neobundle#tap('emmet-vim') " {{{

    function! s:zen_html_tab()
        let line = getline('.')
        if match(line, '<.*>') < 0
            return "\<c-y>,"
        endif
        return "\<c-y>n"
    endfunction
    " let g:user_emmet_leader_key = <Leader>y
    autocmd FileType xml,xsl,xslt,xsd,css,sass,scss,less,mustache imap <buffer><tab> <c-y>,
    autocmd FileType html imap <buffer><expr><tab> <sid>zen_html_tab()

endif " }}}

if neobundle#tap('vim-easymotion') " {{{

    " hi link EasyMotionTarget ErrorMsg
    " hi link EasyMotionShade    Comment

    let g:EasyMotion_skipfoldedline = 0

    map <Space> <Plug>(easymotion-prefix)
    " map s <Plug>(easymotion-s)
    " map t <Plug>(easymotion-t)
    " map    / <Plug>(easymotion-sn)
    " omap / <Plug>(easymotion-tn)
    "map    n <Plug>(easymotion-next)
    "map    N <Plug>(easymotion-prev)
    " map w    <Plug>(easymotion-bd-w)
    " map f    <Plug>(easymotion-bd-f)
    " map <Space> <Plug>(easymotion-jumptoanywhere)

endif " }}}

if neobundle#tap('vim-sneak') " {{{

    hi link SneakPluginTarget ErrorMsg
    hi link SneakPluginScope Comment

    "default is ,
    nmap <C-,> <Plug>SneakPrevious
    nmap <C-.> <Plug>SneakNext

    "fix S
    nmap S <Plug>Sneak_S
    xmap S <Plug>Sneak_S

    "enable clever-s behavior
    let g:sneak#s_next = 1

    "replace 'f' with 1-char Sneak
    nmap f <Plug>Sneak_f
    nmap F <Plug>Sneak_F
    xmap f <Plug>Sneak_f
    xmap F <Plug>Sneak_F
    omap f <Plug>Sneak_f
    omap F <Plug>Sneak_F
    "replace 't' with 1-char Sneak
    nmap t <Plug>Sneak_t
    nmap T <Plug>Sneak_T
    xmap t <Plug>Sneak_t
    xmap T <Plug>Sneak_T
    omap t <Plug>Sneak_t
    omap T <Plug>Sneak_T

endif " }}}

if neobundle#tap('accelerated-jk') " {{{

    nmap j <Plug>(accelerated_jk_gj)
    nmap k <Plug>(accelerated_jk_gk)

endif " }}}

if neobundle#tap('undotree') " {{{

    let g:undotree_WindowLayout = 2
    nnoremap <Leader>u :UndotreeToggle<CR>

endif " }}}

if neobundle#tap('vim-smartinput') " {{{

    call neobundle#config({
                \     'autoload' : {
                \         'insert' : 1
                \     }
                \ })

    function! neobundle#tapped.hooks.on_source(bundle)
        call smartinput#clear_rules()
        call smartinput#define_default_rules()
    endfunction

    function! neobundle#tapped.hooks.on_post_source(bundle)
        call smartinput_endwise#define_default_rules()
    endfunction

    call neobundle#untap()

endif " }}}

if neobundle#tap('vim-smartinput-endwise') " {{{

    function! neobundle#tapped.hooks.on_post_source(bundle)
        " neosnippet and neocomplete compatible
        call smartinput#map_to_trigger('i', '<Plug>(my_cr)', '<Enter>', '<Enter>')
    endfunction

    call neobundle#untap()

endif " }}}

if neobundle#tap('vim-textobj-multitextobj') " {{{

    function! neobundle#tapped.hooks.on_post_source(bundle)
        let g:textobj_multitextobj_textobjects_i = [
                    \     "i(",
                    \     "i[",
                    \     "\<Plug>(textobj-function-i)",
                    \     "\<Plug>(textobj-indent-i)",
                    \]
    endfunction

    omap amt <Plug>(textobj-multitextobj-a)
    omap imt <Plug>(textobj-multitextobj-i)
    vmap amt <Plug>(textobj-multitextobj-a)
    vmap imt <Plug>(textobj-multitextobj-i)

    call neobundle#untap()

endif " }}}

if neobundle#tap('vim-easytags') " {{{

    let g:easytags_dynamic_files = 1
    let g:easytags_include_members = 1
    let g:easytags_async = 1
    let g:easytags_auto_highlight = 0

endif " }}}

if neobundle#tap('vim-marching') " {{{

    let g:marching_enable_neocomplete = 1

endif " }}}

if neobundle#tap('syntastic') " {{{

    " let g:syntastic_python_python_exec = '/bin/python2.7'
    let g:syntastic_python_flake8_args='--ignore=E501'
    let g:syntastic_always_populate_loc_list = 1
    let g:syntastic_auto_loc_list = 1
    let g:syntastic_auto_jump = 2
    " let g:syntastic_check_on_open = 1
    let g:syntastic_check_on_wq = 0
    let g:syntastic_java_javac_config_file_enabled = 1
    let g:syntastic_cpp_check_header = 1
    let g:syntastic_cpp_compiler = 'g++'
    let g:syntastic_cpp_compiler_options = ' -std=c++11'

    nnoremap <Leader>_ :SyntasticToggleMode<CR>
    " nnoremap <Leader>s :SyntasticCheck<CR>

endif " }}}

if neobundle#tap('vim-rooter') " {{{

    let g:rooter_disable_map = 1
    " let g:rooter_manual_only = 1
    " autocmd BufEnter * :Rooter
    " autocmd BufEnter * :SyntasticCheck

endif " }}}

if neobundle#tap('vim-unimpaired') " {{{

    " currently bugged: :move command closes tabs when set to foldmarker
    " Bubble single lines - uses unimpaired plugin actions
    " nnoremap <M-k> [e
    " nnoremap <M-j> ]e
    " Bubble multiple lines
    " xnoremap <M-k> [egv
    " xnoremap <M-j> ]egv

endif " }}}

if neobundle#tap('tabular') " {{{

    nmap <Leader>a& :Tabularize /&<CR>
    vmap <Leader>a& :Tabularize /&<CR>
    nmap <Leader>a= :Tabularize /^[^=]*\zs=<CR>
    vmap <Leader>a= :Tabularize /^[^=]*\zs=<CR>
    nmap <Leader>a=> :Tabularize /=><CR>
    vmap <Leader>a=> :Tabularize /=><CR>
    nmap <Leader>a: :Tabularize /:<CR>
    vmap <Leader>a: :Tabularize /:<CR>
    nmap <Leader>a:: :Tabularize /:\zs<CR>
    vmap <Leader>a:: :Tabularize /:\zs<CR>
    nmap <Leader>a, :Tabularize /,<CR>
    vmap <Leader>a, :Tabularize /,<CR>
    nmap <Leader>a,, :Tabularize /,\zs<CR>
    vmap <Leader>a,, :Tabularize /,\zs<CR>
    nmap <Leader>a<Bar> :Tabularize /<Bar><CR>
    vmap <Leader>a<Bar> :Tabularize /<Bar><CR>

endif " }}}

if neobundle#tap('vim-editvar') " {{{

    call neobundle#config({
                \     'autoload' : {
                \         'commands' : [ 'Editvar' ],
                \         'unite_sources' : [ 'variable' ]
                \     }
                \ })

endif " }}}

if neobundle#tap('unite-tag') " {{{

    call neobundle#config({
                \     'autoload' : {
                \         'unite_sources' : [ 'tag' ]
                \     }
                \ })

endif " }}}

if neobundle#tap('unite-help') " {{{

    call neobundle#config({
                \     'autoload' : {
                \         'unite_sources' : [ 'help' ]
                \     }
                \ })

endif " }}}

if neobundle#tap('foldCC') " {{{

    set foldmethod=marker
    set foldtext=FoldCCtext()
    set foldcolumn=0
    set fillchars=vert:\|

endif " }}}

if neobundle#tap('numbers.vim') " {{{

    let g:numbers_exclude = ['unite', 'goyo', 'undotree', 'vimshell']

endif " }}}

if neobundle#tap('goyo.vim') " {{{

    function! s:goyo_enter()
        augroup linenumbers
            autocmd InsertLeave * :set norelativenumber
        augroup END
        let b:quitting = 0
        let b:quitting_bang = 0
        set noshowmode
        set noshowcmd
        set nocursorline
        set fdm=manual
        exec NumbersToggle()
        set nonumber, norelativenumber
        set scrolloff=999
        let g:neocomplete#disable_auto_complete = 1
        autocmd QuitPre <buffer> let b:quitting = 1
        cabbrev <buffer> q! let b:quitting_bang = 1 <bar> q!
    endfunction

    function! s:goyo_leave()
        augroup linenumbers
            autocmd!
        augroup END
        set showmode
        set showcmd
        set cursorline
        set scrolloff=10
        set fdm=marker
        " set number
        let g:neocomplete#disable_auto_complete = 0
        highlight clear SignColumn
        highlight clear LineNr
        " Quit Vim if this is the only remaining buffer
        if b:quitting && len(filter(range(1, bufnr('$')), 'buflisted(v:val)')) == 1
            if b:quitting_bang
                qa!
            else
                qa
            endif
        endif
    endfunction

    autocmd User GoyoEnter call <SID>goyo_enter()
    autocmd User GoyoLeave call <SID>goyo_leave()

    nnoremap <silent> <leader>z :Goyo<cr>

    " nnoremap <silent> <leader>z :call <SID>goyoWrapper()<cr>
    " function s:goyoWrapper()
    "
    "     if !exists('#linenumbers#BufEnter')
    "             augroup linenumbers
    "                 autocmd!
    "                 autocmd BufEnter *        :set relativenumber
    "                 autocmd BufLeave *        :set number norelativenumber
    "                 autocmd WinEnter *        :set relativenumber
    "                 autocmd WinLeave *        :set number norelativenumber
    "                 autocmd InsertEnter * :set number norelativenumber
    "                 autocmd InsertLeave * :set relativenumber
    "                 autocmd FocusLost *     :set number norelativenumber
    "                 autocmd FocusGained * :set relativenumber
    "             augroup END
    "     else
    "             augroup linenumbers
    "                 autocmd!
    "             augroup END
    "     endif
    "
    "     exec "Goyo"
    "     highlight clear SignColumn
    "     highlight clear LineNr
    " endfunction

endif " }}}

if neobundle#tap('caw.vim') " {{{

    nmap <Leader>c gcc
    vmap <Leader>c gcc

endif " }}}

if neobundle#tap('vim-ctrlspace') " {{{

    function! neobundle#tapped.hooks.on_source(bundle)

        if executable("ag")
            let g:CtrlSpaceGlobCommand = 'ag -l --nocolor -g ""'
        endif

    endfunction

    nnoremap <silent><C-p> :CtrlSpace O<CR>

endif " }}}

if neobundle#tap('vim-over') " {{{

    nnoremap <Leader>s :OverCommandLine<CR>

endif " }}}

if neobundle#tap('lexima.vim') " {{{

    let g:lexima_enable_endwise_rules = 1

endif " }}}

if neobundle#tap('auto-pairs') " {{{

    " let g:AutoPairsFlyMode = 1
    let g:AutoPairsMapBS = 0
    inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>

endif " }}}

if neobundle#tap('vim-argwrap') " {{{

    nnoremap <Leader>l :ArgWrap<CR>

endif " }}}

if neobundle#tap('vim-operator-replace') " {{{

    map _ <Plug>(operator-replace)

endif " }}}

if neobundle#tap('vim-operator-surround') " {{{

    map <silent>sa <Plug>(operator-surround-append)
    map <silent>sd <Plug>(operator-surround-delete)
    map <silent>sr <Plug>(operator-surround-replace)

    nmap <silent>sdd <Plug>(operator-surround-delete)<Plug>(textobj-multiblock-a)
    nmap <silent>srr <Plug>(operator-surround-replace)<Plug>(textobj-multiblock-a)

endif " }}}

if neobundle#tap('vim-textobj-between') " {{{

    let g:textobj_between_no_default_key_mappings = 1
    map ix <Plug>(textobj-between-i)
    map ax <Plug>(textobj-between-a)

endif " }}}

if neobundle#tap('numbers.vim') " {{{

    " exec ":NumbersOnOff<CR>"
    " exec ":NumbersToggle<CR>"
    nnoremap <Leader>n :NumbersOnOff<CR>:NumbersToggle<CR>

endif " }}}

if neobundle#tap('incsearch.vim') " {{{

    set hlsearch
    let g:incsearch#auto_nohlsearch = 1
    map /  <Plug>(incsearch-forward)
    map ?  <Plug>(incsearch-backward)
    map g/ <Plug>(incsearch-stay)
    map n  <Plug>(incsearch-nohl-n)
    map N  <Plug>(incsearch-nohl-N)
    map *  <Plug>(incsearch-nohl-*)
    map #  <Plug>(incsearch-nohl-#)
    map g* <Plug>(incsearch-nohl-g*)
    map g# <Plug>(incsearch-nohl-g#)

    map z/ <Plug>(incsearch-easymotion-/)
    map z? <Plug>(incsearch-easymotion-?)
    map zg/ <Plug>(incsearch-easymotion-stay)

    function! s:config_easyfuzzymotion(...) abort
      return extend(copy({
      \   'converters': [incsearch#config#fuzzy#converter()],
      \   'modules': [incsearch#config#easymotion#module()],
      \   'keymap': {"\<CR>": '<Over>(easymotion)'},
      \   'is_expr': 0,
      \   'is_stay': 1
      \ }), get(a:, 1, {}))
    endfunction

    noremap <silent><expr> <Space>/ incsearch#go(<SID>config_easyfuzzymotion())

endif " }}}

if neobundle#tap('haya14busa/vim-asterisk') " {{{

    map *   <Plug>(asterisk-*)
    map #   <Plug>(asterisk-#)
    map g*  <Plug>(asterisk-g*)
    map g#  <Plug>(asterisk-g#)
    map z*  <Plug>(asterisk-z*)
    map gz* <Plug>(asterisk-gz*)
    map z#  <Plug>(asterisk-z#)
    map gz# <Plug>(asterisk-gz#)

    let g:asterisk#keeppos = 1

endif " }}}

if neobundle#tap('vim-signify') " {{{

    let g:signify_sign_weight = 'none'

    " highlight lines in Sy and vimdiff etc.)

    highlight DiffAdd           cterm=none ctermbg=none ctermfg=119
    highlight DiffDelete        cterm=none ctermbg=none ctermfg=167
    highlight DiffChange        cterm=none ctermbg=none ctermfg=227

    " highlight signs in Sy

    highlight SignifySignAdd    cterm=none ctermbg=none  ctermfg=119
    highlight SignifySignDelete cterm=none ctermbg=none  ctermfg=167
    highlight SignifySignChange cterm=none ctermbg=none  ctermfg=227

endif " }}}

if neobundle#tap('fzf.vim') " {{{

    function! neobundle#tapped.hooks.on_source(bundle)

        function! s:tags_sink(line)
            let parts = split(a:line, '\t\zs')
            let excmd = matchstr(parts[2:], '^.*\ze;"\t')
            execute 'silent e' parts[1][:-2]
            let [magic, &magic] = [&magic, 0]
            execute excmd
            let &magic = magic
        endfunction

        function! s:tags()
            if empty(tagfiles())
                echohl WarningMsg
                echom 'Preparing tags'
                echohl None
                call system('ctags -R')
            endif

            call fzf#run({
                        \ 'source':  'cat '.join(map(tagfiles(), 'fnamemodify(v:val, ":S")')).
                        \            '| grep -v ^!',
                        \ 'options': '+m -d "\t" --with-nth 1,4.. -n 1 --tiebreak=index',
                        \ 'down':    '40%',
                        \ 'sink':    function('s:tags_sink')})
        endfunction

        command! Tags call s:tags()

    endfunction

    nnoremap <Leader>t :Tags<CR>
    nnoremap <C-p> :FZF<CR>

endif " }}}

" }}}

call neobundle#end()
NeoBundleCheck
